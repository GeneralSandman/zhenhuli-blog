

# QQ海量分布式定时器Tikker的实现



> [!TIP|style:flat|label:导语]
> Tikker是一个面向海量用户规模，提供可靠的事件通知服务的分布式定时器系统。Tikker借鉴云原生的思想，为定时器到期处理任务的管理，提供了一个运行在不可靠的环境下的高可靠、去中心化的任务调度和分发机制。Tikker集成的这个分布式分发任务、调度任务的任务管理模块，帮助tikker规避了传统中心化任务系统存在的调度中心单点、无法平行扩容、突发流量系统不稳定等问题。Tikker自2019年7月上线以来，承接了超过了20个业务的接入，包含QQ提醒、QQ机器人定时消息等，并经受住了2021年春节红包活动高达100w/s qps的压测考验，为QQ春节红包活动提供了可靠的定时器服务。

## 一. Tikker总体介绍

### 1.1 Tikker现状


定时本身的需求在各类服务、业务中是十分常见的，尤其广泛存在于在线游戏、推送服务、购物场景乃至支付场景中。在QQ后台中这类需求也是十分常见的。在这样背景下，Tikker2019年7月正式上线运行，截止到现在，包括QQ提醒、自习室、一起听音乐，群课堂等共计20多个业务接入到服务中，新创建的定时器数量约为100w/min。到期的定时器中，绝大部分定时偏差都在100ms内。在今年春节的QQ红包项目中，Tikker为一起party业务提供了定时器服务，并承受了100w/s qps的考验，表现出色。



![](./1.png)


### 1.2 Tikker方案总结

Tikker是一个基于redis的zset实现的一个分布式定时器组件。使用zset实现定时器在业内现在可能已经属于十分常见的设计了，这个方案的基本思路相对而言比较明朗：使用定时器到期时间作为zset的score，不断轮询这个zset，取出score小于当前时间戳的元素，处理回调通知。

Tikker着重关注的问题是如何合理地划分出多个zset，控制单个key的元素规模。最容易想到的是，为每一个定时器计算一个Hash，分到不同的子集中——Tikker使用murmurHash3算法为每一个定时器计算出一个Hash值，映射到m个桶（bucket）中，其中m和tikker预期的qps正相关。但每一个桶中的定时器的到期时间相差很大，还有进一步优化的空间。Tikker的第二个优化措施借鉴了时间轮算法中hash机制，按等大小的时间间隔进一步分割zset，使得定时器的查询、插入、删除等操作只受到到期时间和自己相近的定时器的影响，不仅进一步有效地控制了zset的元素规模，同时有效缩减了同一个时刻需要被轮询的zset的数目。这个部分主要对应着“3.3.2定时器的划分”小节中的内容，

Tikker关注的另外一个问题是，要保证每一个需要被扫描的zset在同一个时刻都恰好被一个task处理到。在任意一个时刻，tikker中需要持续不断的扫描m个zset，对应m个任务，但这些任务不会也不能放在同一台机器上进行。因此需要将m个任务尽可能均匀地分配给不同的机器，保证每一个任务都恰好被一台机器承接了。为此，tikker集成了一个去中心化、可靠的任务管理系统。这个部分对应着“3.3.3 定时器到期查询task的调度”小节中的内容。


## 二. 需求说明

### 2.1 基本功能需求

一个定时服务的基本功能需求包括：

- 定时器的创建： 用户给定定时间隔、到期的回调方式申请创建一个定时器
- 定时器的查找：用户使用唯一的ID查询一个定时器当前的状况：是否存在、是否到期、预计多久到期
- 定时器的删除：用户使用唯一的ID删除一个定时器
- 定时到期回调： 当一个定时器到期的时候，以用户期盼的方式回调通知到用户


### 2.2 基本性能需求


一般而言，用户不使用本地的定时器（例如Linux操作系统的API或是基于此的封装）转而使用远程的定时器服务，往往一个决定的因素是机器故障引发的定时器丢失的后果是难以承受的。这种丢失的可能性随着定时跨度的增大而不断升高（当然鉴于目前后远程服务调用的便利性，一个好用的定时器服务本身就有足够的魅力去吸引有需要的业务去使用）。因此，一个“好用”定时器服务，至少需要实现以下两个基本的特性:

- 可被接受的定时精度


由于网络时延的存在，远程定时器服务可容忍的定时精度不会像本地定时器一样要求高精度的准确性，目前接入的业务本身都允许几百ms到秒级左右的定时回调通知偏差。

- 定时服务高可靠


对定时器丢失的容忍度非常低，保证创建成功的定时器回调都能通知到对方。鉴于目前我们了解到的exactly-once的相关做法往往需要在接收端进行必要的处理，这对使用者一方而言有可能难以接受，因而at-least-once是一个比较恰当的选择。


### 2.3 进阶要求

但是要成为一个“不错”的定时器组件，除了上述两个基本的要求，还应该实现如下几个特性:

- 高性能 ： 在保证定时精度和服务可靠性的前提下，承接大量乃是海量的定时器接入
- 高可用 ： 保障服务不因为机器的故障出现服务异常或者中断，避免单点故障的影响
- 可伸缩： 可以简单、快捷地对服务进行扩容和缩容，用来支持不同时段定时器接入规模发生波动的场景



![]()
![]()





